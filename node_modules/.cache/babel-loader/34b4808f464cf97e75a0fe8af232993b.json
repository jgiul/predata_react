{"ast":null,"code":"import { inferTypes, typeParsers } from './type';\nimport { formats } from './formats/index';\nimport { timeFormatDefaultLocale } from 'vega-format';\nimport { error, hasOwnProperty } from 'vega-util';\nexport default function (data, schema, timeParser, utcParser) {\n  schema = schema || {};\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\n\nfunction parse(data, types, timeParser, utcParser) {\n  if (!data.length) return; // early exit for empty data\n\n  const locale = timeFormatDefaultLocale();\n  timeParser = timeParser || locale.timeParse;\n  utcParser = utcParser || locale.utcParse;\n  let fields = data.columns || Object.keys(data[0]),\n      datum,\n      field,\n      i,\n      j,\n      n,\n      m;\n  if (types === 'auto') types = inferTypes(data, fields);\n  fields = Object.keys(types);\n  const parsers = fields.map(field => {\n    const type = types[field];\n    let parts, pattern;\n\n    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\n      parts = type.split(/:(.+)?/, 2); // split on first :\n\n      pattern = parts[1];\n\n      if (pattern[0] === '\\'' && pattern[pattern.length - 1] === '\\'' || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n        pattern = pattern.slice(1, -1);\n      }\n\n      const parse = parts[0] === 'utc' ? utcParser : timeParser;\n      return parse(pattern);\n    }\n\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return typeParsers[type];\n  });\n\n  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {\n    datum = data[i];\n\n    for (j = 0; j < m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/jg443z/1234/node_modules/vega-loader/src/read.js"],"names":["inferTypes","typeParsers","formats","timeFormatDefaultLocale","error","hasOwnProperty","data","schema","timeParser","utcParser","reader","type","parse","columns","types","length","locale","timeParse","utcParse","fields","Object","keys","datum","field","i","j","n","m","parsers","map","parts","pattern","startsWith","split","slice","Error"],"mappings":"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","sourcesContent":["import {inferTypes, typeParsers} from './type';\nimport {formats} from './formats/index';\nimport {timeFormatDefaultLocale} from 'vega-format';\nimport {error, hasOwnProperty} from 'vega-util';\n\nexport default function(data, schema, timeParser, utcParser) {\n  schema = schema || {};\n\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\n\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\n\nfunction parse(data, types, timeParser, utcParser) {\n  if (!data.length) return; // early exit for empty data\n\n  const locale = timeFormatDefaultLocale();\n  timeParser = timeParser || locale.timeParse;\n  utcParser = utcParser || locale.utcParse;\n\n  let fields = data.columns || Object.keys(data[0]),\n      datum, field, i, j, n, m;\n\n  if (types === 'auto') types = inferTypes(data, fields);\n\n  fields = Object.keys(types);\n  const parsers = fields.map(field => {\n    const type = types[field];\n    let parts, pattern;\n\n    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\n      parts = type.split(/:(.+)?/, 2);  // split on first :\n      pattern = parts[1];\n\n      if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n          (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n        pattern = pattern.slice(1, -1);\n      }\n\n      const parse = parts[0] === 'utc' ? utcParser : timeParser;\n      return parse(pattern);\n    }\n\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return typeParsers[type];\n  });\n\n  for (i=0, n=data.length, m=fields.length; i<n; ++i) {\n    datum = data[i];\n    for (j=0; j<m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}