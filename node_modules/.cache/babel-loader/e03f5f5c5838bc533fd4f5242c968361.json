{"ast":null,"code":"import { field, isDate, toNumber, isArray, inrange, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\nconst Intersect = 'intersect';\nconst Union = 'union';\nconst VlMulti = 'vlMulti';\nconst Or = 'or';\nconst And = 'and';\nvar TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0,\n      dval,\n      f;\n\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry,\n      miss,\n      count,\n      unit,\n      b;\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n\n  return n && intersect;\n}\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @returns {object} An object of selected fields and values.\n */\n\n\nfunction selectionResolve(name, op, isMulti) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    } // If the same multi-selection is repeated over views and projected over\n    // an encoding, it may operate over different fields making it especially\n    // tricky to reliably resolve it. At best, we can de-dupe identical entries\n    // but doing so may be more computationally expensive than it is worth.\n    // Instead, for now, we simply transform our store representation into\n    // a more human-friendly one.\n\n\n    if (isMulti) {\n      resUnit = multiRes[unit] || (multiRes[unit] = []);\n      resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n  Object.keys(resolved).forEach(field => {\n    resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));\n  });\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    resolved[VlMulti] = op === Union ? {\n      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])\n    } : {\n      [And]: entries.map(k => ({\n        [Or]: multiRes[k]\n      }))\n    };\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  E_union: function (base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n\n    return base;\n  },\n  E_intersect: function (base, value) {\n    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);\n  },\n  R_union: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport { selectionResolve, selectionTest, selectionVisitor };","map":{"version":3,"sources":["/Users/jg443z/1234/node_modules/vega-selections/build/vega-selection.module.js"],"names":["field","isDate","toNumber","isArray","inrange","array","error","peek","hasOwnProperty","Literal","Intersect","Union","VlMulti","Or","And","TYPE_ENUM","TYPE_RANGE_INC","TYPE_RANGE_EXC","TYPE_RANGE_LE","TYPE_RANGE_RE","UNIT_INDEX","testPoint","datum","entry","fields","values","n","length","i","dval","f","getter","map","type","indexOf","selectionTest","name","op","data","context","entries","value","unitIdx","undefined","intersect","miss","count","unit","b","size","get","selectionResolve","isMulti","resolved","multiRes","types","res","resUnit","union","j","m","charAt","ops","push","reduce","obj","curr","Object","keys","forEach","acc","k","E_union","base","E_intersect","filter","v","R_union","lo","hi","R_intersect","DataPrefix","IndexPrefix","selectionVisitor","args","scope","params","indexName","dataName","getData","indataRef","tuplesRef"],"mappings":"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","sourcesContent":["import { field, isDate, toNumber, isArray, inrange, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\n\nconst Intersect = 'intersect';\nconst Union = 'union';\nconst VlMulti = 'vlMulti';\nconst Or = 'or';\nconst And = 'and';\n\nvar TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0,\n      dval,\n      f;\n\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry,\n      miss,\n      count,\n      unit,\n      b;\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n\n  return n && intersect;\n}\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @returns {object} An object of selected fields and values.\n */\n\nfunction selectionResolve(name, op, isMulti) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    } // If the same multi-selection is repeated over views and projected over\n    // an encoding, it may operate over different fields making it especially\n    // tricky to reliably resolve it. At best, we can de-dupe identical entries\n    // but doing so may be more computationally expensive than it is worth.\n    // Instead, for now, we simply transform our store representation into\n    // a more human-friendly one.\n\n\n    if (isMulti) {\n      resUnit = multiRes[unit] || (multiRes[unit] = []);\n      resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n  Object.keys(resolved).forEach(field => {\n    resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));\n  });\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    resolved[VlMulti] = op === Union ? {\n      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])\n    } : {\n      [And]: entries.map(k => ({\n        [Or]: multiRes[k]\n      }))\n    };\n  }\n\n  return resolved;\n}\nvar ops = {\n  E_union: function (base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n\n    return base;\n  },\n  E_intersect: function (base, value) {\n    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);\n  },\n  R_union: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport { selectionResolve, selectionTest, selectionVisitor };\n"]},"metadata":{},"sourceType":"module"}