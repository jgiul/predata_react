{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { SELECTION_ID } from '../../selection';\nimport { vals } from '../../util';\nimport { isFacetModel } from '../model';\nimport interval from './interval';\nimport multi from './multi';\nimport single from './single';\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\nexport const VL_SELECTION_RESOLVE = 'vlSelectionResolve';\nconst compilers = {\n  single,\n  multi,\n  interval\n};\nexport function forEachSelection(model, cb) {\n  const selections = model.component.selection;\n\n  if (selections) {\n    for (const sel of vals(selections)) {\n      const success = cb(sel, compilers[sel.type]);\n      if (success === true) break;\n    }\n  }\n}\n\nfunction getFacetModel(model) {\n  let parent = model.parent;\n\n  while (parent) {\n    if (isFacetModel(parent)) {\n      break;\n    }\n\n    parent = parent.parent;\n  }\n\n  return parent;\n}\n\nexport function unitName(model, {\n  escape\n} = {\n  escape: true\n}) {\n  let name = escape ? stringValue(model.name) : model.name;\n  const facetModel = getFacetModel(model);\n\n  if (facetModel) {\n    const {\n      facet\n    } = facetModel;\n\n    for (const channel of FACET_CHANNELS) {\n      if (facet[channel]) {\n        name += ` + '__facet_${channel}_' + (facet[${stringValue(facetModel.vgField(channel))}])`;\n      }\n    }\n  }\n\n  return name;\n}\nexport function requiresSelectionId(model) {\n  let identifier = false;\n  forEachSelection(model, selCmpt => {\n    identifier = identifier || selCmpt.project.items.some(proj => proj.field === SELECTION_ID);\n  });\n  return identifier;\n}","map":{"version":3,"sources":["../../../../src/compile/selection/index.ts"],"names":[],"mappings":"AACA,SAAQ,WAAR,QAA0B,WAA1B;AACA,SAAQ,cAAR,QAA6B,eAA7B;AACA,SAOE,YAPF,QAQO,iBARP;AASA,SAAc,IAAd,QAAyB,YAAzB;AAGA,SAAQ,YAAR,QAAkC,UAAlC;AAEA,OAAO,QAAP,MAAqB,YAArB;AACA,OAAO,KAAP,MAAkB,SAAlB;AACA,OAAO,MAAP,MAAmB,UAAnB;AAGA,OAAO,MAAM,KAAK,GAAG,QAAd;AACP,OAAO,MAAM,KAAK,GAAG,QAAd;AACP,OAAO,MAAM,MAAM,GAAG,SAAf;AACP,OAAO,MAAM,gBAAgB,GAAG,oBAAzB;AACP,OAAO,MAAM,oBAAoB,GAAG,oBAA7B;AAqCP,MAAM,SAAS,GAA4B;AAAC,EAAA,MAAD;AAAS,EAAA,KAAT;AAAgB,EAAA;AAAhB,CAA3C;AAEA,OAAM,SAAU,gBAAV,CACJ,KADI,EAEJ,EAFI,EAE+E;AAEnF,QAAM,UAAU,GAAG,KAAK,CAAC,SAAN,CAAgB,SAAnC;;AACA,MAAI,UAAJ,EAAgB;AACd,SAAK,MAAM,GAAX,IAAkB,IAAI,CAAC,UAAD,CAAtB,EAAoC;AAClC,YAAM,OAAO,GAAG,EAAE,CAAC,GAAD,EAAM,SAAS,CAAC,GAAG,CAAC,IAAL,CAAf,CAAlB;AACA,UAAI,OAAO,KAAK,IAAhB,EAAsB;AACvB;AACF;AACF;;AAED,SAAS,aAAT,CAAuB,KAAvB,EAAmC;AACjC,MAAI,MAAM,GAAG,KAAK,CAAC,MAAnB;;AACA,SAAO,MAAP,EAAe;AACb,QAAI,YAAY,CAAC,MAAD,CAAhB,EAA0B;AACxB;AACD;;AACD,IAAA,MAAM,GAAG,MAAM,CAAC,MAAhB;AACD;;AAED,SAAO,MAAP;AACD;;AAED,OAAM,SAAU,QAAV,CAAmB,KAAnB,EAAiC;AAAC,EAAA;AAAD,IAAW;AAAC,EAAA,MAAM,EAAE;AAAT,CAA5C,EAA0D;AAC9D,MAAI,IAAI,GAAG,MAAM,GAAG,WAAW,CAAC,KAAK,CAAC,IAAP,CAAd,GAA6B,KAAK,CAAC,IAApD;AACA,QAAM,UAAU,GAAG,aAAa,CAAC,KAAD,CAAhC;;AACA,MAAI,UAAJ,EAAgB;AACd,UAAM;AAAC,MAAA;AAAD,QAAU,UAAhB;;AACA,SAAK,MAAM,OAAX,IAAsB,cAAtB,EAAsC;AACpC,UAAI,KAAK,CAAC,OAAD,CAAT,EAAoB;AAClB,QAAA,IAAI,IAAI,eAAe,OAAO,eAAe,WAAW,CAAC,UAAU,CAAC,OAAX,CAAmB,OAAnB,CAAD,CAA6B,IAArF;AACD;AACF;AACF;;AACD,SAAO,IAAP;AACD;AAED,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAA0C;AAC9C,MAAI,UAAU,GAAG,KAAjB;AACA,EAAA,gBAAgB,CAAC,KAAD,EAAQ,OAAO,IAAG;AAChC,IAAA,UAAU,GAAG,UAAU,IAAI,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAAsB,IAAtB,CAA2B,IAAI,IAAI,IAAI,CAAC,KAAL,KAAe,YAAlD,CAA3B;AACD,GAFe,CAAhB;AAGA,SAAO,UAAP;AACD","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { SELECTION_ID } from '../../selection';\nimport { vals } from '../../util';\nimport { isFacetModel } from '../model';\nimport interval from './interval';\nimport multi from './multi';\nimport single from './single';\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\nexport const VL_SELECTION_RESOLVE = 'vlSelectionResolve';\nconst compilers = { single, multi, interval };\nexport function forEachSelection(model, cb) {\n    const selections = model.component.selection;\n    if (selections) {\n        for (const sel of vals(selections)) {\n            const success = cb(sel, compilers[sel.type]);\n            if (success === true)\n                break;\n        }\n    }\n}\nfunction getFacetModel(model) {\n    let parent = model.parent;\n    while (parent) {\n        if (isFacetModel(parent)) {\n            break;\n        }\n        parent = parent.parent;\n    }\n    return parent;\n}\nexport function unitName(model, { escape } = { escape: true }) {\n    let name = escape ? stringValue(model.name) : model.name;\n    const facetModel = getFacetModel(model);\n    if (facetModel) {\n        const { facet } = facetModel;\n        for (const channel of FACET_CHANNELS) {\n            if (facet[channel]) {\n                name += ` + '__facet_${channel}_' + (facet[${stringValue(facetModel.vgField(channel))}])`;\n            }\n        }\n    }\n    return name;\n}\nexport function requiresSelectionId(model) {\n    let identifier = false;\n    forEachSelection(model, selCmpt => {\n        identifier = identifier || selCmpt.project.items.some(proj => proj.field === SELECTION_ID);\n    });\n    return identifier;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}