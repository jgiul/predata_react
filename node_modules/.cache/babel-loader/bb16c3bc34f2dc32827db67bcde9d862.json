{"ast":null,"code":"import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { selector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize(spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\n\nfunction parsePadding(spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\n\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\n\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n\n  return encode;\n}\n\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults(encode, type, role, style, config) {\n  const defaults = {},\n        enter = {};\n  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? \"(\".concat(scale.signal, \")\") : field(scale);\n\nfunction entry(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? \"(\".concat(enc.signal, \")\") : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = \"pow(\".concat(value, \",\").concat(property(enc.exponent), \")\");\n  }\n\n  if (enc.mult != null) {\n    value += \"*\".concat(property(enc.mult));\n  }\n\n  if (enc.offset != null) {\n    value += \"+\".concat(property(enc.offset));\n  }\n\n  if (enc.round) {\n    value = \"round(\".concat(value, \")\");\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) => \"(\".concat(type, \"(\").concat([x, y, z].map(entry).join(','), \")+'')\");\n\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_)); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return \"gradient(\".concat(args.join(','), \")\");\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = \"lerp(_range(\".concat(scale, \"), \").concat(+enc.range, \")\");\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = \"_scale(\".concat(scale, \", \").concat(value, \")\");\n\n    if (enc.band) {\n      value = (value ? value + '+' : '') + \"_bandwidth(\".concat(scale, \")\") + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = \"(datum.extra ? _scale(\".concat(scale, \", datum.extra.value) : \").concat(value, \")\");\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction rule(enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry(rule);\n    code += rule.test ? \"(\".concat(rule.test, \")?\").concat(value, \":\") : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n\nfunction parseEncode(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry(enc);\n}\n\nfunction parse(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nfunction parseSignal(signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nfunction entry$1(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nfunction operator(value, params) {\n  return entry$1('operator', value, params);\n} // -----\n\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nfunction fieldRef(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\n\nconst keyFieldRef = fieldRef('key');\n\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\n\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\n\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\n\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\n\nconst Scope = 'scope';\nconst View = 'view';\n\nfunction isSignal(_) {\n  return _ && _.signal;\n}\n\nfunction isExpr(_) {\n  return _ && _.expr;\n}\n\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\n\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n  return source === Scope ? View : source || View;\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({\n    merge: list\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n\n  if (stream.source === Scope) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\n\nfunction parseUpdate(spec, scope, target) {\n  const encode = spec.encode,\n        entry = {\n    target: target\n  };\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = selector(events, scope.isSubscope() ? Scope : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry$1(name, value, params || undefined, parent);\n\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\n\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\n\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef$1(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef$1(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v; // get value counts for each domain field\n\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection(proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter(proj[name], name, scope);\n  } // apply projection defaults from config\n\n\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n  return _;\n}\n\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\n\nfunction anchorExpr(s, e, m) {\n  return \"item.anchor === '\".concat(Start, \"' ? \").concat(s, \" : item.anchor === '\").concat(End, \"' ? \").concat(e, \" : \").concat(m);\n}\n\nconst alignExpr = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\n\nfunction tickBand(_) {\n  const v = _('tickBand');\n\n  let offset = _('tickOffset'),\n      band,\n      extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: \"(\".concat(v.signal, \") === 'extent' ? 1 : 0.5\")\n    };\n    extra = {\n      signal: \"(\".concat(v.signal, \") === 'extent'\")\n    };\n\n    if (!isObject(offset)) {\n      offset = {\n        signal: \"(\".concat(v.signal, \") === 'extent' ? 0 : \").concat(offset)\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {\n    extra,\n    band,\n    offset\n  };\n}\n\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n\n  return mark;\n}\n\nfunction legendGradient(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u,\n      v,\n      uu,\n      vv,\n      adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr$1 = \"datum.\".concat(Perc, \"<=0?\\\"\").concat(Left, \"\\\":datum.\").concat(Perc, \">=1?\\\"\").concat(Right, \"\\\":\\\"\").concat(Center, \"\\\"\"),\n      baselineExpr = \"datum.\".concat(Perc, \"<=0?\\\"\").concat(Bottom, \"\\\":datum.\").concat(Perc, \">=1?\\\"\").concat(Top, \"\\\":\\\"\").concat(Middle, \"\\\"\");\n\nfunction legendGradientLabels(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter,\n      update,\n      u,\n      v,\n      adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr$1\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction legendSymbolGroups(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {\n    data: 'value'\n  },\n        xSignal = \"(\".concat(columns, \") ? datum.\").concat(Offset, \" : datum.\").concat(Size),\n        yEncode = height ? encoder(height) : {\n    field: Size\n  },\n        index = \"datum.\".concat(Index),\n        ncols = \"max(1, \".concat(columns, \")\");\n\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = \"ceil(item.mark.items.length / \".concat(ncols, \")\");\n    update.row.signal = \"\".concat(index, \"%\").concat(nrows);\n    update.column.signal = \"floor(\".concat(index, \" / \").concat(nrows, \")\");\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = \"floor(\".concat(index, \" / \").concat(ncols, \")\");\n    update.column.signal = \"\".concat(index, \" % \").concat(ncols);\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = \"(\".concat(columns, \")?\").concat(update.column.signal, \":\").concat(index); // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\n\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = \"(\".concat(isL, \" || \").concat(isR, \")\"),\n      isVG = \"datum.vgrad && \".concat(isLR),\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = \"datum.vgrad && \".concat(isR, \" ? (\").concat(alignFlip, \") : (\").concat(isLR, \" && !(datum.vgrad && \").concat(isL, \")) ? \\\"left\\\" : \").concat(alignExpr),\n      exprAnchor = \"item._anchor || (\".concat(isLR, \" ? \\\"middle\\\" : \\\"start\\\")\"),\n      exprAngle = \"\".concat(isVG, \" ? (\").concat(isL, \" ? -90 : 90) : 0\"),\n      exprBaseline = \"\".concat(isLR, \" ? (datum.vgrad ? (\").concat(isR, \" ? \\\"bottom\\\" : \\\"top\\\") : \").concat(baseline, \") : \\\"top\\\"\");\n\nfunction legendTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip(clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr ? scope.signalRef(expr) : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole(spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition(spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n/**\n * Parse a data transform specification.\n */\n\n\nfunction parseTransform(spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry$1(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\n\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter$1(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter$1(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr$1(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef(value.field, value.as) : isExpr$1(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef; // loop over defs to find matching key\n\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nconst outerExpr = _ => _ && _.expr;\n\nconst outerField = _ => _ && _.field;\n\nconst isData = _ => _ === 'data';\n\nconst isExpr$1 = _ => _ === 'expr';\n\nconst isField = _ => _ === 'field';\n\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData(from, group, scope) {\n  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n      if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n      if (facet.field != null) {\n        dataRef = parent = getDataRef(facet, scope);\n      } else {\n        // generate facet aggregates if no direct data specification\n        if (!from.data) {\n          op = parseTransform(extend({\n            type: 'aggregate',\n            groupby: array(facet.groupby)\n          }, facet.aggregate), scope);\n          op.params.key = scope.keyRef(facet.groupby);\n          op.params.pulse = getDataRef(facet, scope);\n          dataRef = parent = ref(scope.add(op));\n        } else {\n          parent = ref(scope.getData(from.data).aggregate);\n        }\n\n        key = scope.keyRef(facet.groupby, true);\n      }\n    } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n        values = entries[n - 1],\n        output = entries[n - 2];\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n  let k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry$1(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n\n};\n\nfunction parseFacet(spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow(spec, scope, input) {\n  const op = scope.add(PreFacet({\n    pulse: input.pulse\n  })),\n        subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger(spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark(spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops,\n      op,\n      store,\n      enc,\n      name,\n      layoutRef,\n      boundRef;\n  const nested = role === MarkRole || layout || facet; // resolve input data\n\n  const input = parseData(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  const render = scope.add(Render({\n    pulse: boundRef\n  })),\n        sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend(spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0,\n      entryLayout,\n      params,\n      children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(\"max(2,2*floor((\".concat(deref(_.gradientLength()), \")/100))\"));\n  } // discrete gradient legend\n  else if (type === Discrete) {\n      children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n    } // symbol legend\n    else {\n        // determine legend symbol group layout\n        entryLayout = legendSymbolLayout(spec, config);\n        children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n        params.size = sizeExpression(spec, scope, children[0].marks);\n      } // generate legend marks\n\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(\"max(ceil(sqrt(\".concat(size, \")+\").concat(strokeWidth, \"),\").concat(fontSize, \")\"), scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? \"scale(\\\"\".concat(spec[name], \"\\\",datum)\") : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = \"item.orient===\\\"\".concat(Left, \"\\\"?-90:item.orient===\\\"\").concat(Right, \"\\\"?90:0\");\n\nfunction parseTitle(spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = []; // single-element data source for group title\n\n\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\n\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.text,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.subtitle,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData$1(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\n\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (hasSignal(data.values) || hasSignal(data.format)) {\n      // if either values or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\n\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\n\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\n\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(\"\".concat($orient, \" === '\").concat(Top, \"' || \").concat($orient, \" === '\").concat(Bottom, \"'\"), a, b);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(\"\".concat($orient, \" !== '\").concat(Top, \"' && \").concat($orient, \" !== '\").concat(Bottom, \"'\"), a, b);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(\"\".concat($orient, \" === '\").concat(Left, \"' || \").concat($orient, \" === '\").concat(Top, \"'\"), a, b);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(\"\".concat($orient, \" === '\").concat(Top, \"'\"), a, b);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(\"\".concat($orient, \" === '\").concat(Right, \"'\"), a, b);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: \"\".concat(test, \" ? (\").concat(a, \") : (\").concat(b, \")\")\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\nconst ifExpr = (test, a, b) => ({\n  signal: \"\".concat(test, \" ? (\").concat(toExpr(a), \") : (\").concat(toExpr(b), \")\")\n});\n\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? \"\".concat($orient, \" === '\").concat(Left, \"' ? (\").concat(toExpr(l), \") : \") : '') + (b != null ? \"\".concat($orient, \" === '\").concat(Bottom, \"' ? (\").concat(toExpr(b), \") : \") : '') + (r != null ? \"\".concat($orient, \" === '\").concat(Right, \"' ? (\").concat(toExpr(r), \") : \") : '') + (t != null ? \"\".concat($orient, \" === '\").concat(Top, \"' ? (\").concat(toExpr(t), \") : \") : '') + '(null)'\n});\n\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: \"(\".concat(sign.signal, \") * \").concat(value)\n} : {\n  value: sign * value\n};\n\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key in obj) map[key] = 1;\n  }\n\n  return Object.keys(map);\n}\n\nfunction axisConfig(spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy,\n      or,\n      key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n\n    or = {};\n\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ;else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: \"(\".concat(sign.signal, \") * (\").concat(offset || 0, \")\")\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: \"(\".concat(entry.mult, \") * (\").concat(sign.signal, \")\")\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n\n    entry.mult = sign;\n  }\n  return offset;\n}\n\nfunction axisTicks(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nfunction axisLabels(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, \"-(\".concat(flushOffset, \")\"), flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n\n  const bound = _('labelBound');\n\n  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: \"lerp(range(\\\"\".concat(spec.scale, \"\\\"), \").concat(anchorExpr(0, 1, 0.5), \")\")\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis(spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_); // single-element data source for axis group\n\n\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  const children = [];\n  let size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: \"abs(span(range(\\\"\".concat(spec.scale, \"\\\")))\")\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n  scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n  array(spec.data).forEach(_ => parseData$1(_, scope)); // parse scale definitions\n\n  scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n  array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n  array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n  array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\n\nfunction parseView(spec, scope) {\n  const config = scope.config; // add scenegraph root\n\n  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  const input = scope.add(Collect()); // encode root group item\n\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\n\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {}; // add spec signal array\n\n\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope$1(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope$1.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n\n    function annotate(op, name, type) {\n      let data, list;\n\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n\n    this._parent.push(parent);\n\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n\n    this._parent.pop();\n\n    this._lookup.pop();\n\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n\n  // ----\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef(field, name);\n\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    const a = aggrField(sort.op, sort.field),\n          o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n\n  // ----\n  event(source, type) {\n    const key = source + ':' + type;\n\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n\n    return this.events[key];\n  },\n\n  // ----\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n\n  // ----\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.data[name] = dataScope;\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\n\n\nfunction defaults() {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse$1(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope$1(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope$1 as Scope, ScopeRole, defaults as config, parse$1 as parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };","map":{"version":3,"sources":["/Users/jg443z/1234/node_modules/vega-parser/build/vega-parser.module.js"],"names":["isObject","isArray","extend","hasOwnProperty","array","stringValue","peek","isString","error","splitAccessPath","mergeConfig","parseExpression","selector","isValidScaleType","isDiscrete","isQuantile","isDiscretizing","isContinuous","definition","definition$1","parseAutosize","spec","type","number","_","paddingObject","top","bottom","left","right","parsePadding","signal","encoder","value","addEncode","object","name","set","isEncoder","length","update","addEncoders","enter","extendEncode","encode","extra","skip","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendBandRole","LegendEntryRole","LegendGradientRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleRole","TitleTextRole","TitleSubtitleRole","applyDefaults","role","style","config","defaults","props","applyDefault","String","startsWith","group","mark","forEach","scaleRef","scale","concat","field","entry","enc","gradient","color","undefined","exponent","property","mult","offset","round","_color","x","y","z","map","join","c","h","l","s","a","b","r","g","args","start","stop","count","pop","unshift","ref","resolveField","datum","level","parent","Math","max","range","band","rule","code","test","parseEncode","scope","params","encoders","$encode","parseBlock","block","marktype","channels","fields","parse","expr","$expr","$fields","Object","keys","$output","$params","OUTER","OUTER_INVALID","outerError","prefix","parseSignal","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","id","entry$1","operator","$ref","refs","fieldRef","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","keyRef","flat","$key","$flat","Ascending","Descending","sortKey","sort","order","aggrField","Scope","View","isSignal","isExpr","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","method","merge","mergeStream","nestedStream","eventStream","eventSource","source","list","streamParameters","addStream","event","throttle","between","filter","param","markname","markrole","filterMark","debounce","consume","item","OP_VALUE_EXPR","ast","parseUpdate","target","events","sources","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","parseSignalUpdates","getSignal","init","initonly","on","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","initScale","addScale","domain","parseScale","getScale","parseScaleDomain","parseScaleRange","interpolate","parseScaleInterpolate","nice","parseScaleNice","bins","parseScaleBins","parseLiteral","parseArray","dataLookupError","domainMin","domainMax","explicitDomain","multipleDomain","singularDomain","data","getData","valuesRef","parseSort","domainRef","extentRef","reduce","dom","d","fieldRef$1","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","coll","$ingest","input","addDataPipeline","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","objectProperty","interval","step","gamma","interpolateGamma","scheme","extent","schemeExtent","schemeCount","rangeStep","parseProjection","proj","projection","parseParameter","addProjection","Top","Left","Right","Bottom","Center","Vertical","Start","Middle","End","Index","Label","Offset","Perc","Perc2","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","Shape","Fill","Stroke","StrokeWidth","StrokeDash","Opacity","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","SymbolMark","TextMark","guideGroup","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","getStyle","anchorExpr","e","m","alignExpr","tickBand","extendOffset","assign","guideMark","extras","legendGradient","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","legendGradientDiscrete","dataRef","u","uu","vv","adjust","from","alignExpr$1","baselineExpr","legendGradientLabels","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","legendSymbolGroups","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","facet","marks","legendSymbolLayout","center","padding","isL","isR","isLR","isVG","alignFlip","exprAlign","exprAnchor","exprAngle","exprBaseline","legendTitle","orient","_anchor","anchor","angle","title","lineHeight","path","sphere","getRole","indexOf","zindex","aria","description","parseTransform","def","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","parseParameter$1","parseIndexParameter","required","parseSubParameters","projectionRef","parameterValue","isExpr$1","isField","isCompare","outerExpr","exprRef","outerField","isData","lookupRef","parseSubParameter","k","parseData","getDataRef","aggregate","output","DataScope","aggr","fromEntries","fieldKey","addSortField","cache","ds","optype","prototype","agg","tuplesRef","indataRef","parseFacet","subscope","fork","addData","subflow","$subflow","toRuntime","parseSubflow","parseTrigger","remove","insert","toggle","modify","trigger","parseMark","layout","store","layoutRef","boundRef","nested","clean","joinRef","markdef","context","$context","groups","markpath","markRef","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","popState","parseOverlap","render","sieve","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","parseLegend","legend","legendEncode","scales","entryLayout","children","legendType","scaleType","vgrad","entryEncode","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","sizeExpression","buildLegendEncode","scaleCount","titlePadding","cornerRadius","getChannel","getFontSize","angleExpr","parseTitle","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","dx","dy","parseData$1","transforms","analyze","generate","upstream","load","collect","$format","url","$request","modifies","derive","splice","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","ifRight","ifRightExpr","$orient","ifEnc","ifExpr","isSimple","toExpr","ifOrient","sign","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","axis","axisBand","xy","or","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","result","axisDomain","strokeCap","strokeOpacity","pos0","position","pos1","x2","y2","pos","axisGrid","vscale","gridScale","offsetValue","tickPos","sz","gridStart","gridEnd","axisTicks","tickSize","flushExpr","threshold","axisLabels","flush","flushOffset","labelAlign","labelBaseline","flushOn","offsetExpr","axisTitle","titlePos","autoLayout","auto","dim","autoY","autoX","parseAxis","axisEncode","ticks","grid","ticksRef","tickCount","buildAxisEncode","minExtent","maxExtent","translate","parseScope","preprocessed","projections","axes","parseLambdas","rootEncode","parseView","root","collectSignals","eventConfig","locale","autosize","signalObject","pre","Scope$1","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","finish","vref","annotate","cmp","check","sig","o","hasOwnSignal","propertyLambda","addScaleProj","projectionType","dataScope","arrayLambda","objectLambda","defaultFont","defaultSymbolSize","defaultStrokeWidth","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","parse$1","signalUpdates"],"mappings":"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","sourcesContent":["import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { selector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize (spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\n\nfunction parsePadding (spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n\n  return encode;\n}\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults (encode, type, role, style, config) {\n  const defaults = {},\n        enter = {};\n  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? \"(\".concat(scale.signal, \")\") : field(scale);\n\nfunction entry(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? \"(\".concat(enc.signal, \")\") : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = \"pow(\".concat(value, \",\").concat(property(enc.exponent), \")\");\n  }\n\n  if (enc.mult != null) {\n    value += \"*\".concat(property(enc.mult));\n  }\n\n  if (enc.offset != null) {\n    value += \"+\".concat(property(enc.offset));\n  }\n\n  if (enc.round) {\n    value = \"round(\".concat(value, \")\");\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) => \"(\".concat(type, \"(\").concat([x, y, z].map(entry).join(','), \")+'')\");\n\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_)); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return \"gradient(\".concat(args.join(','), \")\");\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = \"lerp(_range(\".concat(scale, \"), \").concat(+enc.range, \")\");\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = \"_scale(\".concat(scale, \", \").concat(value, \")\");\n\n    if (enc.band) {\n      value = (value ? value + '+' : '') + \"_bandwidth(\".concat(scale, \")\") + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = \"(datum.extra ? _scale(\".concat(scale, \", datum.extra.value) : \").concat(value, \")\");\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction rule (enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry(rule);\n    code += rule.test ? \"(\".concat(rule.test, \")?\").concat(value, \":\") : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n\nfunction parseEncode (encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry(enc);\n}\n\nfunction parse(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nfunction parseSignal (signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\nfunction entry$1(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\nfunction operator(value, params) {\n  return entry$1('operator', value, params);\n} // -----\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\nfunction fieldRef(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\nconst keyFieldRef = fieldRef('key');\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\nconst Scope = 'scope';\nconst View = 'view';\nfunction isSignal(_) {\n  return _ && _.signal;\n}\nfunction isExpr(_) {\n  return _ && _.expr;\n}\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n  return source === Scope ? View : source || View;\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({\n    merge: list\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n\n  if (stream.source === Scope) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\nfunction parseUpdate (spec, scope, target) {\n  const encode = spec.encode,\n        entry = {\n    target: target\n  };\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = selector(events, scope.isSubscope() ? Scope : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates (signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry$1(name, value, params || undefined, parent);\n\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\n\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef$1(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef$1(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v; // get value counts for each domain field\n\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection (proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter(proj[name], name, scope);\n  } // apply projection defaults from config\n\n\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\n\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup (mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n  return _;\n}\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\nfunction anchorExpr(s, e, m) {\n  return \"item.anchor === '\".concat(Start, \"' ? \").concat(s, \" : item.anchor === '\").concat(End, \"' ? \").concat(e, \" : \").concat(m);\n}\nconst alignExpr = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\nfunction tickBand(_) {\n  const v = _('tickBand');\n\n  let offset = _('tickOffset'),\n      band,\n      extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: \"(\".concat(v.signal, \") === 'extent' ? 1 : 0.5\")\n    };\n    extra = {\n      signal: \"(\".concat(v.signal, \") === 'extent'\")\n    };\n\n    if (!isObject(offset)) {\n      offset = {\n        signal: \"(\".concat(v.signal, \") === 'extent' ? 0 : \").concat(offset)\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {\n    extra,\n    band,\n    offset\n  };\n}\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark (mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n\n  return mark;\n}\n\nfunction legendGradient (spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u,\n      v,\n      uu,\n      vv,\n      adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr$1 = \"datum.\".concat(Perc, \"<=0?\\\"\").concat(Left, \"\\\":datum.\").concat(Perc, \">=1?\\\"\").concat(Right, \"\\\":\\\"\").concat(Center, \"\\\"\"),\n      baselineExpr = \"datum.\".concat(Perc, \"<=0?\\\"\").concat(Bottom, \"\\\":datum.\").concat(Perc, \">=1?\\\"\").concat(Top, \"\\\":\\\"\").concat(Middle, \"\\\"\");\nfunction legendGradientLabels (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter,\n      update,\n      u,\n      v,\n      adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr$1\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction legendSymbolGroups (spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {\n    data: 'value'\n  },\n        xSignal = \"(\".concat(columns, \") ? datum.\").concat(Offset, \" : datum.\").concat(Size),\n        yEncode = height ? encoder(height) : {\n    field: Size\n  },\n        index = \"datum.\".concat(Index),\n        ncols = \"max(1, \".concat(columns, \")\");\n\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = \"ceil(item.mark.items.length / \".concat(ncols, \")\");\n    update.row.signal = \"\".concat(index, \"%\").concat(nrows);\n    update.column.signal = \"floor(\".concat(index, \" / \").concat(nrows, \")\");\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = \"floor(\".concat(index, \" / \").concat(ncols, \")\");\n    update.column.signal = \"\".concat(index, \" % \").concat(ncols);\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = \"(\".concat(columns, \")?\").concat(update.column.signal, \":\").concat(index); // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = \"(\".concat(isL, \" || \").concat(isR, \")\"),\n      isVG = \"datum.vgrad && \".concat(isLR),\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = \"datum.vgrad && \".concat(isR, \" ? (\").concat(alignFlip, \") : (\").concat(isLR, \" && !(datum.vgrad && \").concat(isL, \")) ? \\\"left\\\" : \").concat(alignExpr),\n      exprAnchor = \"item._anchor || (\".concat(isLR, \" ? \\\"middle\\\" : \\\"start\\\")\"),\n      exprAngle = \"\".concat(isVG, \" ? (\").concat(isL, \" ? -90 : 90) : 0\"),\n      exprBaseline = \"\".concat(isLR, \" ? (datum.vgrad ? (\").concat(isR, \" ? \\\"bottom\\\" : \\\"top\\\") : \").concat(baseline, \") : \\\"top\\\"\");\nfunction legendTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip (clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr ? scope.signalRef(expr) : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole (spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition (spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive (spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n\n/**\n * Parse a data transform specification.\n */\n\nfunction parseTransform (spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry$1(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter$1(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter$1(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr$1(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef(value.field, value.as) : isExpr$1(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef; // loop over defs to find matching key\n\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nconst outerExpr = _ => _ && _.expr;\nconst outerField = _ => _ && _.field;\nconst isData = _ => _ === 'data';\nconst isExpr$1 = _ => _ === 'expr';\nconst isField = _ => _ === 'field';\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData (from, group, scope) {\n  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n      if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n      if (facet.field != null) {\n        dataRef = parent = getDataRef(facet, scope);\n      } else {\n        // generate facet aggregates if no direct data specification\n        if (!from.data) {\n          op = parseTransform(extend({\n            type: 'aggregate',\n            groupby: array(facet.groupby)\n          }, facet.aggregate), scope);\n          op.params.key = scope.keyRef(facet.groupby);\n          op.params.pulse = getDataRef(facet, scope);\n          dataRef = parent = ref(scope.add(op));\n        } else {\n          parent = ref(scope.getData(from.data).aggregate);\n        }\n\n        key = scope.keyRef(facet.groupby, true);\n      }\n    } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n        values = entries[n - 1],\n        output = entries[n - 2];\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n  let k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry$1(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n\n};\n\nfunction parseFacet (spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow (spec, scope, input) {\n  const op = scope.add(PreFacet({\n    pulse: input.pulse\n  })),\n        subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger (spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark (spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops,\n      op,\n      store,\n      enc,\n      name,\n      layoutRef,\n      boundRef;\n  const nested = role === MarkRole || layout || facet; // resolve input data\n\n  const input = parseData(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  const render = scope.add(Render({\n    pulse: boundRef\n  })),\n        sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend (spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0,\n      entryLayout,\n      params,\n      children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(\"max(2,2*floor((\".concat(deref(_.gradientLength()), \")/100))\"));\n  } // discrete gradient legend\n  else if (type === Discrete) {\n      children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n    } // symbol legend\n    else {\n        // determine legend symbol group layout\n        entryLayout = legendSymbolLayout(spec, config);\n        children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n        params.size = sizeExpression(spec, scope, children[0].marks);\n      } // generate legend marks\n\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(\"max(ceil(sqrt(\".concat(size, \")+\").concat(strokeWidth, \"),\").concat(fontSize, \")\"), scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? \"scale(\\\"\".concat(spec[name], \"\\\",datum)\") : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = \"item.orient===\\\"\".concat(Left, \"\\\"?-90:item.orient===\\\"\").concat(Right, \"\\\"?90:0\");\nfunction parseTitle (spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = []; // single-element data source for group title\n\n\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.text,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.subtitle,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData$1(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (hasSignal(data.values) || hasSignal(data.format)) {\n      // if either values or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(\"\".concat($orient, \" === '\").concat(Top, \"' || \").concat($orient, \" === '\").concat(Bottom, \"'\"), a, b);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(\"\".concat($orient, \" !== '\").concat(Top, \"' && \").concat($orient, \" !== '\").concat(Bottom, \"'\"), a, b);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(\"\".concat($orient, \" === '\").concat(Left, \"' || \").concat($orient, \" === '\").concat(Top, \"'\"), a, b);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(\"\".concat($orient, \" === '\").concat(Top, \"'\"), a, b);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(\"\".concat($orient, \" === '\").concat(Right, \"'\"), a, b);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: \"\".concat(test, \" ? (\").concat(a, \") : (\").concat(b, \")\")\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\nconst ifExpr = (test, a, b) => ({\n  signal: \"\".concat(test, \" ? (\").concat(toExpr(a), \") : (\").concat(toExpr(b), \")\")\n});\n\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? \"\".concat($orient, \" === '\").concat(Left, \"' ? (\").concat(toExpr(l), \") : \") : '') + (b != null ? \"\".concat($orient, \" === '\").concat(Bottom, \"' ? (\").concat(toExpr(b), \") : \") : '') + (r != null ? \"\".concat($orient, \" === '\").concat(Right, \"' ? (\").concat(toExpr(r), \") : \") : '') + (t != null ? \"\".concat($orient, \" === '\").concat(Top, \"' ? (\").concat(toExpr(t), \") : \") : '') + '(null)'\n});\n\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: \"(\".concat(sign.signal, \") * \").concat(value)\n} : {\n  value: sign * value\n};\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key in obj) map[key] = 1;\n  }\n\n  return Object.keys(map);\n}\n\nfunction axisConfig (spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy,\n      or,\n      key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n\n    or = {};\n\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid (spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ; else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: \"(\".concat(sign.signal, \") * (\").concat(offset || 0, \")\")\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: \"(\".concat(entry.mult, \") * (\").concat(sign.signal, \")\")\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n\nfunction axisTicks (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nfunction axisLabels (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, \"-(\".concat(flushOffset, \")\"), flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n\n  const bound = _('labelBound');\n\n  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: \"lerp(range(\\\"\".concat(spec.scale, \"\\\"), \").concat(anchorExpr(0, 1, 0.5), \")\")\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis (spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_); // single-element data source for axis group\n\n\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  const children = [];\n  let size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: \"abs(span(range(\\\"\".concat(spec.scale, \"\\\")))\")\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope (spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n  scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n  array(spec.data).forEach(_ => parseData$1(_, scope)); // parse scale definitions\n\n  scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n  array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n  array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n  array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\n\nfunction parseView(spec, scope) {\n  const config = scope.config; // add scenegraph root\n\n  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  const input = scope.add(Collect()); // encode root group item\n\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\n\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {}; // add spec signal array\n\n\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope$1(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope$1.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n\n    function annotate(op, name, type) {\n      let data, list;\n\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n\n    this._parent.push(parent);\n\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n\n    this._parent.pop();\n\n    this._lookup.pop();\n\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n\n  // ----\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef(field, name);\n\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    const a = aggrField(sort.op, sort.field),\n          o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n\n  // ----\n  event(source, type) {\n    const key = source + ':' + type;\n\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n\n    return this.events[key];\n  },\n\n  // ----\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n\n  // ----\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.data[name] = dataScope;\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults () {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse$1 (spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope$1(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope$1 as Scope, ScopeRole, defaults as config, parse$1 as parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };\n"]},"metadata":{},"sourceType":"module"}