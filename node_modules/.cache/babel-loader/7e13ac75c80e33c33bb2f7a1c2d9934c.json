{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBand, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { DEFAULT_STEP, getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { hasDiscreteDomain, ScaleType } from '../../../scale';\nimport { getFirstDefined } from '../../../util';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n  var _a, _b, _c, _d;\n\n  const {\n    config,\n    encoding,\n    markDef,\n    stack\n  } = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const channelDef = encoding[channel];\n  const channelDef2 = encoding[channel2];\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaleName = model.scaleName(channel);\n  const orient = markDef.orient;\n  const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal'); // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !hasSizeDef && !hasDiscreteDomain(scaleType)) {\n    const band = getBand({\n      channel,\n      fieldDef: channelDef,\n      stack,\n      markDef,\n      config\n    });\n    const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n    const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel,\n      markDef,\n      scaleName,\n      band,\n      axisTranslate,\n      spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n      reverse: scale.get('reverse'),\n      config\n    });\n  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType) || isBarBand) && !channelDef2) {\n    return positionAndSize(mark, channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction defaultSizeRef(mark, sizeChannel, scaleName, scale, config, band) {\n  if (scale) {\n    const scaleType = scale.get('type');\n\n    if (scaleType === 'point' || scaleType === 'band') {\n      if (config[mark].discreteBandSize !== undefined) {\n        return {\n          value: config[mark].discreteBandSize\n        };\n      }\n\n      if (scaleType === ScaleType.POINT) {\n        const scaleRange = scale.get('range');\n\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n          return {\n            value: scaleRange.step - 2\n          };\n        }\n\n        return {\n          value: DEFAULT_STEP - 2\n        };\n      } else {\n        // BAND\n        return {\n          scale: scaleName,\n          band\n        };\n      }\n    } else {\n      // continuous scale\n      return {\n        value: config[mark].continuousBandSize\n      };\n    }\n  } // No Scale\n\n\n  const step = getViewConfigDiscreteStep(config.view, sizeChannel);\n  const value = getFirstDefined( // No scale is like discrete bar (with one item)\n  config[mark].discreteBandSize, step - 2);\n  return value !== undefined ? {\n    value\n  } : undefined;\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\n\n\nfunction positionAndSize(mark, fieldDef, channel, model) {\n  var _a;\n\n  const {\n    markDef,\n    encoding,\n    config,\n    stack\n  } = model;\n  const orient = markDef.orient;\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const vgSizeChannel = getSizeChannel(channel);\n  const channel2 = getSecondaryRangeChannel(channel); // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n\n  const useVlSizeChannel = orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x';\n  const sizeFromMarkOrConfig = getMarkPropOrConfig(useVlSizeChannel ? 'size' : vgSizeChannel, markDef, config, {\n    vgChannel: vgSizeChannel\n  }); // Use size encoding / mark property / config if it exists\n\n  let sizeMixins;\n\n  if (encoding.size || sizeFromMarkOrConfig !== undefined) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultValue: sizeFromMarkOrConfig\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  } // Otherwise, apply default value\n\n\n  const band = (_a = isFieldOrDatumDef(fieldDef) ? getBand({\n    channel,\n    fieldDef,\n    markDef,\n    stack,\n    config\n  }) : undefined) !== null && _a !== void 0 ? _a : 1;\n  sizeMixins = sizeMixins || {\n    [vgSizeChannel]: defaultSizeRef(mark, vgSizeChannel, scaleName, scale, config, band)\n  };\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n       Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n\n  const center = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]);\n  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, center ? 'middle' : 'top');\n  const offset = getOffset(channel, markDef);\n  const posRef = ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: fieldDef,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: pointPositionDefaultRef({\n      model,\n      defaultPos: 'mid',\n      channel,\n      scaleName,\n      scale\n    }),\n    band: center ? 0.5 : (1 - band) / 2\n  });\n\n  if (vgSizeChannel) {\n    return Object.assign({\n      [vgChannel]: posRef\n    }, sizeMixins);\n  } else {\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const sizeRef = sizeMixins[vgSizeChannel];\n    const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), {\n      offset\n    }) : sizeRef;\n    return {\n      [vgChannel]: posRef,\n      // posRef might be an array that wraps position invalid test\n      [vgChannel2]: isArray(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), {\n        offset: sizeOffset\n      })] : Object.assign(Object.assign({}, posRef), {\n        offset: sizeOffset\n      })\n    };\n  }\n}\n\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n\n  const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n    const reverseExpr = signalOrStringValue(reverse);\n    const offsetExpr = signalOrStringValue(offset);\n    const translateExpr = signalOrStringValue(translate);\n    const t = translateExpr ? `${translateExpr} + ` : '';\n    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n    const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\n\nexport function rectBinPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  band,\n  scaleName,\n  markDef,\n  spacing = 0,\n  axisTranslate,\n  reverse,\n  config\n}) {\n  const channel2 = getSecondaryRangeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const vgChannel2 = getVgPositionChannel(channel2);\n  const offset = getOffset(channel, markDef);\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    return {\n      [vgChannel2]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: (1 - band) / 2,\n        offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n        config\n      }),\n      [vgChannel]: rectBinRef({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: 1 - (1 - band) / 2,\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n        config\n      })\n    };\n  } else if (isBinned(fieldDef.bin)) {\n    const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n    });\n\n    if (isFieldDef(fieldDef2)) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {\n          offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n        })\n      };\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: {\n          signal: `scale(\"${scaleName}\", ${vgField(fieldDef, {\n            expr: 'datum'\n          })} + ${fieldDef.bin.step})`,\n          offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n        }\n      };\n    }\n  }\n\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function rectBinRef({\n  channel,\n  fieldDef,\n  scaleName,\n  markDef,\n  band,\n  offset,\n  config\n}) {\n  const r = ref.interpolatedSignalRef({\n    scaleName,\n    fieldOrDatumDef: fieldDef,\n    band,\n    offset\n  });\n  return ref.wrapPositionInvalidTest({\n    fieldDef,\n    channel,\n    markDef,\n    ref: r,\n    config\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-rect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBand, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { DEFAULT_STEP, getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { hasDiscreteDomain, ScaleType } from '../../../scale';\nimport { getFirstDefined } from '../../../util';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { getOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n    var _a, _b, _c, _d;\n    const { config, encoding, markDef, stack } = model;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const channelDef = encoding[channel];\n    const channelDef2 = encoding[channel2];\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const scaleName = model.scaleName(channel);\n    const orient = markDef.orient;\n    const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, { vgChannel: sizeChannel });\n    const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal');\n    // x, x2, and width -- we must specify two of these in all conditions\n    if (isFieldDef(channelDef) &&\n        (isBinning(channelDef.bin) || isBinned(channelDef.bin) || (channelDef.timeUnit && !channelDef2)) &&\n        !hasSizeDef &&\n        !hasDiscreteDomain(scaleType)) {\n        const band = getBand({ channel, fieldDef: channelDef, stack, markDef, config });\n        const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];\n        const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _d !== void 0 ? _d : 0.5; // vega default is 0.5\n        return rectBinPosition({\n            fieldDef: channelDef,\n            fieldDef2: channelDef2,\n            channel,\n            markDef,\n            scaleName,\n            band,\n            axisTranslate,\n            spacing: isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) : undefined,\n            reverse: scale.get('reverse'),\n            config\n        });\n    }\n    else if (((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType)) || isBarBand) && !channelDef2) {\n        return positionAndSize(mark, channelDef, channel, model);\n    }\n    else {\n        return rangePosition(channel, model, { defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin' });\n    }\n}\nfunction defaultSizeRef(mark, sizeChannel, scaleName, scale, config, band) {\n    if (scale) {\n        const scaleType = scale.get('type');\n        if (scaleType === 'point' || scaleType === 'band') {\n            if (config[mark].discreteBandSize !== undefined) {\n                return { value: config[mark].discreteBandSize };\n            }\n            if (scaleType === ScaleType.POINT) {\n                const scaleRange = scale.get('range');\n                if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n                    return { value: scaleRange.step - 2 };\n                }\n                return { value: DEFAULT_STEP - 2 };\n            }\n            else {\n                // BAND\n                return { scale: scaleName, band };\n            }\n        }\n        else {\n            // continuous scale\n            return { value: config[mark].continuousBandSize };\n        }\n    }\n    // No Scale\n    const step = getViewConfigDiscreteStep(config.view, sizeChannel);\n    const value = getFirstDefined(\n    // No scale is like discrete bar (with one item)\n    config[mark].discreteBandSize, step - 2);\n    return value !== undefined ? { value } : undefined;\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(mark, fieldDef, channel, model) {\n    var _a;\n    const { markDef, encoding, config, stack } = model;\n    const orient = markDef.orient;\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const vgSizeChannel = getSizeChannel(channel);\n    const channel2 = getSecondaryRangeChannel(channel);\n    // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n    const useVlSizeChannel = (orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x');\n    const sizeFromMarkOrConfig = getMarkPropOrConfig(useVlSizeChannel ? 'size' : vgSizeChannel, markDef, config, {\n        vgChannel: vgSizeChannel\n    });\n    // Use size encoding / mark property / config if it exists\n    let sizeMixins;\n    if (encoding.size || sizeFromMarkOrConfig !== undefined) {\n        if (useVlSizeChannel) {\n            sizeMixins = nonPosition('size', model, { vgChannel: vgSizeChannel, defaultValue: sizeFromMarkOrConfig });\n        }\n        else {\n            log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n        }\n    }\n    // Otherwise, apply default value\n    const band = (_a = (isFieldOrDatumDef(fieldDef) ? getBand({ channel, fieldDef, markDef, stack, config }) : undefined)) !== null && _a !== void 0 ? _a : 1;\n    sizeMixins = sizeMixins || { [vgSizeChannel]: defaultSizeRef(mark, vgSizeChannel, scaleName, scale, config, band) };\n    /*\n      Band scales with size value and all point scales, use xc/yc + band=0.5\n  \n      Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n      In this case, size_band is the band specified in the x/y-encoding.\n      By default band is 1, so `(1 - band) / 2` = 0.\n      If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n     */\n    const center = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]);\n    const vgChannel = vgAlignedPositionChannel(channel, markDef, config, center ? 'middle' : 'top');\n    const offset = getOffset(channel, markDef);\n    const posRef = ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: fieldDef,\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: pointPositionDefaultRef({ model, defaultPos: 'mid', channel, scaleName, scale }),\n        band: center ? 0.5 : (1 - band) / 2\n    });\n    if (vgSizeChannel) {\n        return Object.assign({ [vgChannel]: posRef }, sizeMixins);\n    }\n    else {\n        // otherwise, we must simulate size by setting position2 = position + size\n        // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n        const vgChannel2 = getVgPositionChannel(channel2);\n        const sizeRef = sizeMixins[vgSizeChannel];\n        const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), { offset }) : sizeRef;\n        return {\n            [vgChannel]: posRef,\n            // posRef might be an array that wraps position invalid test\n            [vgChannel2]: isArray(posRef)\n                ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })]\n                : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })\n        };\n    }\n}\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n    if (isPolarPositionChannel(channel)) {\n        return 0;\n    }\n    const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n    if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n        const reverseExpr = signalOrStringValue(reverse);\n        const offsetExpr = signalOrStringValue(offset);\n        const translateExpr = signalOrStringValue(translate);\n        const t = translateExpr ? `${translateExpr} + ` : '';\n        const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n        const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n        return {\n            signal: t + r + o\n        };\n    }\n    else {\n        offset = offset || 0;\n        return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n    }\n}\nexport function rectBinPosition({ fieldDef, fieldDef2, channel, band, scaleName, markDef, spacing = 0, axisTranslate, reverse, config }) {\n    const channel2 = getSecondaryRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const offset = getOffset(channel, markDef);\n    if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n        return {\n            [vgChannel2]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                band: (1 - band) / 2,\n                offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset),\n                config\n            }),\n            [vgChannel]: rectBinRef({\n                channel,\n                fieldDef,\n                scaleName,\n                markDef,\n                band: 1 - (1 - band) / 2,\n                offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset),\n                config\n            })\n        };\n    }\n    else if (isBinned(fieldDef.bin)) {\n        const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset) });\n        if (isFieldDef(fieldDef2)) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset) })\n            };\n        }\n        else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: {\n                    signal: `scale(\"${scaleName}\", ${vgField(fieldDef, { expr: 'datum' })} + ${fieldDef.bin.step})`,\n                    offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n                }\n            };\n        }\n    }\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n}\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef({ channel, fieldDef, scaleName, markDef, band, offset, config }) {\n    const r = ref.interpolatedSignalRef({\n        scaleName,\n        fieldOrDatumDef: fieldDef,\n        band,\n        offset\n    });\n    return ref.wrapPositionInvalidTest({\n        fieldDef,\n        channel,\n        markDef,\n        ref: r,\n        config\n    });\n}\n//# sourceMappingURL=position-rect.js.map"]},"metadata":{},"sourceType":"module"}