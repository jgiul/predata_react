{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../../util';\nimport { TimeUnitNode } from '../../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n  constructor(...items) {\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n  }\n\n}\nconst project = {\n  has: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: (model, selCmpt, selDef) => {\n    var _a, _b, _c;\n\n    const name = selCmpt.name;\n    const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();\n    const parsed = {};\n    const timeUnits = {};\n    const signals = new Set();\n\n    const signalName = (p, range) => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n\n      signals.add(sg);\n      return {\n        [range]: sg\n      };\n    }; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    // Otherwise, use the default configuration.\n\n\n    if (!selDef.fields && !selDef.encodings) {\n      const cfg = model.config.selection[selDef.type];\n\n      if (selDef.init) {\n        for (const init of array(selDef.init)) {\n          for (const key of keys(init)) {\n            if (isSingleDefUnitChannel(key)) {\n              (selDef.encodings || (selDef.encodings = [])).push(key);\n            } else {\n              if (selDef.type === 'interval') {\n                log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                selDef.encodings = cfg.encodings;\n              } else {\n                (selDef.fields || (selDef.fields = [])).push(key);\n              }\n            }\n          }\n        }\n      } else {\n        selDef.encodings = cfg.encodings;\n        selDef.fields = cfg.fields;\n      }\n    } // TODO: find a possible channel mapping for these fields.\n\n\n    for (const field of (_b = selDef.fields) !== null && _b !== void 0 ? _b : []) {\n      const p = {\n        type: 'E',\n        field\n      };\n      p.signals = Object.assign({}, signalName(p, 'data'));\n      proj.items.push(p);\n      proj.hasField[field] = p;\n    }\n\n    for (const channel of (_c = selDef.encodings) !== null && _c !== void 0 ? _c : []) {\n      const fieldDef = model.fieldDef(channel);\n\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n\n          const component = {\n            timeUnit: fieldDef.timeUnit,\n            as: field,\n            field: fieldDef.field\n          };\n          timeUnits[hash(component)] = component;\n        } // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let type = 'E';\n\n          if (selCmpt.type === 'interval') {\n            const scaleType = model.getScaleComponent(channel).get('type');\n\n            if (hasContinuousDomain(scaleType)) {\n              type = 'R';\n            }\n          } else if (fieldDef.bin) {\n            type = 'R-RE';\n          }\n\n          const p = {\n            field,\n            channel,\n            type\n          };\n          p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n          proj.items.push(parsed[field] = p);\n          proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    if (selDef.init) {\n      const parseInit = i => {\n        return proj.items.map(p => i[p.channel] !== undefined ? i[p.channel] : i[p.field]);\n      };\n\n      if (selDef.type === 'interval') {\n        selCmpt.init = parseInit(selDef.init);\n      } else {\n        const init = array(selDef.init);\n        selCmpt.init = init.map(parseInit);\n      }\n    }\n\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0 ? allSignals : allSignals.concat({\n      name,\n      value: selCmpt.project.items.map(proj => {\n        const {\n          signals,\n          hasLegend\n        } = proj,\n              rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n\n        rest.field = replacePathInField(rest.field);\n        return rest;\n      })\n    });\n  }\n};\nexport default project;","map":{"version":3,"sources":["../../../../../src/compile/selection/transforms/project.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../../util';\nimport { TimeUnitNode } from '../../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n    constructor(...items) {\n        this.items = items;\n        this.hasChannel = {};\n        this.hasField = {};\n    }\n}\nconst project = {\n    has: () => {\n        return true; // This transform handles its own defaults, so always run parse.\n    },\n    parse: (model, selCmpt, selDef) => {\n        var _a, _b, _c;\n        const name = selCmpt.name;\n        const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : (selCmpt.project = new SelectionProjectionComponent());\n        const parsed = {};\n        const timeUnits = {};\n        const signals = new Set();\n        const signalName = (p, range) => {\n            const suffix = range === 'visual' ? p.channel : p.field;\n            let sg = varName(`${name}_${suffix}`);\n            for (let counter = 1; signals.has(sg); counter++) {\n                sg = varName(`${name}_${suffix}_${counter}`);\n            }\n            signals.add(sg);\n            return { [range]: sg };\n        };\n        // If no explicit projection (either fields or encodings) is specified, set some defaults.\n        // If an initial value is set, try to infer projections.\n        // Otherwise, use the default configuration.\n        if (!selDef.fields && !selDef.encodings) {\n            const cfg = model.config.selection[selDef.type];\n            if (selDef.init) {\n                for (const init of array(selDef.init)) {\n                    for (const key of keys(init)) {\n                        if (isSingleDefUnitChannel(key)) {\n                            (selDef.encodings || (selDef.encodings = [])).push(key);\n                        }\n                        else {\n                            if (selDef.type === 'interval') {\n                                log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                                selDef.encodings = cfg.encodings;\n                            }\n                            else {\n                                (selDef.fields || (selDef.fields = [])).push(key);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                selDef.encodings = cfg.encodings;\n                selDef.fields = cfg.fields;\n            }\n        }\n        // TODO: find a possible channel mapping for these fields.\n        for (const field of (_b = selDef.fields) !== null && _b !== void 0 ? _b : []) {\n            const p = { type: 'E', field };\n            p.signals = Object.assign({}, signalName(p, 'data'));\n            proj.items.push(p);\n            proj.hasField[field] = p;\n        }\n        for (const channel of (_c = selDef.encodings) !== null && _c !== void 0 ? _c : []) {\n            const fieldDef = model.fieldDef(channel);\n            if (fieldDef) {\n                let field = fieldDef.field;\n                if (fieldDef.aggregate) {\n                    log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n                    continue;\n                }\n                else if (!field) {\n                    log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n                    continue;\n                }\n                if (fieldDef.timeUnit) {\n                    field = model.vgField(channel);\n                    // Construct TimeUnitComponents which will be combined into a\n                    // TimeUnitNode. This node may need to be inserted into the\n                    // dataflow if the selection is used across views that do not\n                    // have these time units defined.\n                    const component = {\n                        timeUnit: fieldDef.timeUnit,\n                        as: field,\n                        field: fieldDef.field\n                    };\n                    timeUnits[hash(component)] = component;\n                }\n                // Prevent duplicate projections on the same field.\n                // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n                if (!parsed[field]) {\n                    // Determine whether the tuple will store enumerated or ranged values.\n                    // Interval selections store ranges for continuous scales, and enumerations otherwise.\n                    // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n                    let type = 'E';\n                    if (selCmpt.type === 'interval') {\n                        const scaleType = model.getScaleComponent(channel).get('type');\n                        if (hasContinuousDomain(scaleType)) {\n                            type = 'R';\n                        }\n                    }\n                    else if (fieldDef.bin) {\n                        type = 'R-RE';\n                    }\n                    const p = { field, channel, type };\n                    p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n                    proj.items.push((parsed[field] = p));\n                    proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n                }\n            }\n            else {\n                log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            }\n        }\n        if (selDef.init) {\n            const parseInit = (i) => {\n                return proj.items.map(p => (i[p.channel] !== undefined ? i[p.channel] : i[p.field]));\n            };\n            if (selDef.type === 'interval') {\n                selCmpt.init = parseInit(selDef.init);\n            }\n            else {\n                const init = array(selDef.init);\n                selCmpt.init = init.map(parseInit);\n            }\n        }\n        if (!isEmpty(timeUnits)) {\n            proj.timeUnit = new TimeUnitNode(null, timeUnits);\n        }\n    },\n    signals: (model, selCmpt, allSignals) => {\n        const name = selCmpt.name + TUPLE_FIELDS;\n        const hasSignal = allSignals.filter(s => s.name === name);\n        return hasSignal.length > 0\n            ? allSignals\n            : allSignals.concat({\n                name,\n                value: selCmpt.project.items.map(proj => {\n                    const { signals, hasLegend } = proj, rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n                    rest.field = replacePathInField(rest.field);\n                    return rest;\n                })\n            });\n    }\n};\nexport default project;\n//# sourceMappingURL=project.js.map"]},"metadata":{},"sourceType":"module"}