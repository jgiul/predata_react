{"ast":null,"code":"import { error, extend, isFunction, stringValue } from 'vega-util'; // Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\n\nconst protocol_re = /^([A-Za-z]+:)?\\/\\//; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\n\nconst allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\n\nconst whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n// Special treatment in node.js for the file: protocol\n\nconst fileProtocol = 'file://';\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\n\nexport default function (fetch, fs) {\n  return options => ({\n    options: options || {},\n    sanitize: sanitize,\n    load: load,\n    fileAccess: !!fs,\n    file: fileLoader(fs),\n    http: httpLoader(fetch)\n  });\n}\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\n\nasync function load(uri, options) {\n  const opt = await this.sanitize(uri, options),\n        url = opt.href;\n  return opt.localFile ? this.file(url) : this.http(url, options);\n}\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to sanity check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\n\n\nasync function sanitize(uri, options) {\n  options = extend({}, this.options, options);\n  const fileAccess = this.fileAccess,\n        result = {\n    href: null\n  };\n  let isFile, loadFile, base;\n  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n\n  if (uri == null || typeof uri !== 'string' || !isAllowed) {\n    error('Sanitize failure, invalid URI: ' + stringValue(uri));\n  }\n\n  const hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL\n\n  if ((base = options.baseURL) && !hasProtocol) {\n    // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    if (!uri.startsWith('/') && base[base.length - 1] !== '/') {\n      uri = '/' + uri;\n    }\n\n    uri = base + uri;\n  } // should we load from file system?\n\n\n  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;\n\n  if (isFile) {\n    // strip file protocol\n    uri = uri.slice(fileProtocol.length);\n  } else if (uri.startsWith('//')) {\n    if (options.defaultProtocol === 'file') {\n      // if is file, strip protocol and set loadFile flag\n      uri = uri.slice(2);\n      loadFile = true;\n    } else {\n      // if relative protocol (starts with '//'), prepend default protocol\n      uri = (options.defaultProtocol || 'http') + ':' + uri;\n    }\n  } // set non-enumerable mode flag to indicate local file load\n\n\n  Object.defineProperty(result, 'localFile', {\n    value: !!loadFile\n  }); // set uri\n\n  result.href = uri; // set default result target, if specified\n\n  if (options.target) {\n    result.target = options.target + '';\n  } // set default result rel, if specified (#1542)\n\n\n  if (options.rel) {\n    result.rel = options.rel + '';\n  } // provide control over cross-origin image handling (#2238)\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\n\n\n  if (options.context === 'image' && options.crossOrigin) {\n    result.crossOrigin = options.crossOrigin + '';\n  } // return\n\n\n  return result;\n}\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\n\n\nfunction fileLoader(fs) {\n  return fs ? filename => new Promise((accept, reject) => {\n    fs.readFile(filename, (error, data) => {\n      if (error) reject(error);else accept(data);\n    });\n  }) : fileReject;\n}\n/**\n * Default file system loader that simply rejects.\n */\n\n\nasync function fileReject() {\n  error('No file system access.');\n}\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\n\n\nfunction httpLoader(fetch) {\n  return fetch ? async function (url, options) {\n    const opt = extend({}, this.options.http, options),\n          type = options && options.response,\n          response = await fetch(url, opt);\n    return !response.ok ? error(response.status + '' + response.statusText) : isFunction(response[type]) ? response[type]() : response.text();\n  } : httpReject;\n}\n/**\n * Default http request handler that simply rejects.\n */\n\n\nasync function httpReject() {\n  error('No HTTP fetch method available.');\n}","map":{"version":3,"sources":["/Users/jg443z/1234/node_modules/vega-loader/src/loader.js"],"names":["error","extend","isFunction","stringValue","protocol_re","allowed_re","whitespace_re","fileProtocol","fetch","fs","options","sanitize","load","fileAccess","file","fileLoader","http","httpLoader","uri","opt","url","href","localFile","result","isFile","loadFile","base","isAllowed","test","replace","hasProtocol","baseURL","startsWith","length","mode","slice","defaultProtocol","Object","defineProperty","value","target","rel","context","crossOrigin","filename","Promise","accept","reject","readFile","data","fileReject","type","response","ok","status","statusText","text","httpReject"],"mappings":"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","sourcesContent":["import {error, extend, isFunction, stringValue} from 'vega-util';\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nconst protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\nconst allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\nconst whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n\n\n// Special treatment in node.js for the file: protocol\nconst fileProtocol = 'file://';\n\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\nexport default function(fetch, fs) {\n  return options => ({\n    options: options || {},\n    sanitize: sanitize,\n    load: load,\n    fileAccess: !!fs,\n    file: fileLoader(fs),\n    http: httpLoader(fetch)\n  });\n}\n\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\nasync function load(uri, options) {\n  const opt = await this.sanitize(uri, options),\n        url = opt.href;\n\n  return opt.localFile\n    ? this.file(url)\n    : this.http(url, options);\n}\n\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to sanity check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\nasync function sanitize(uri, options) {\n  options = extend({}, this.options, options);\n\n  const fileAccess = this.fileAccess,\n        result = {href: null};\n\n  let isFile, loadFile, base;\n\n  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n\n  if (uri == null || typeof uri !== 'string' || !isAllowed) {\n    error('Sanitize failure, invalid URI: ' + stringValue(uri));\n  }\n\n  const hasProtocol = protocol_re.test(uri);\n\n  // if relative url (no protocol/host), prepend baseURL\n  if ((base = options.baseURL) && !hasProtocol) {\n    // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    if (!uri.startsWith('/') && base[base.length-1] !== '/') {\n      uri = '/' + uri;\n    }\n    uri = base + uri;\n  }\n\n  // should we load from file system?\n  loadFile = (isFile = uri.startsWith(fileProtocol))\n    || options.mode === 'file'\n    || options.mode !== 'http' && !hasProtocol && fileAccess;\n\n  if (isFile) {\n    // strip file protocol\n    uri = uri.slice(fileProtocol.length);\n  } else if (uri.startsWith('//')) {\n    if (options.defaultProtocol === 'file') {\n      // if is file, strip protocol and set loadFile flag\n      uri = uri.slice(2);\n      loadFile = true;\n    } else {\n      // if relative protocol (starts with '//'), prepend default protocol\n      uri = (options.defaultProtocol || 'http') + ':' + uri;\n    }\n  }\n\n  // set non-enumerable mode flag to indicate local file load\n  Object.defineProperty(result, 'localFile', {value: !!loadFile});\n\n  // set uri\n  result.href = uri;\n\n  // set default result target, if specified\n  if (options.target) {\n    result.target = options.target + '';\n  }\n\n  // set default result rel, if specified (#1542)\n  if (options.rel) {\n    result.rel = options.rel + '';\n  }\n\n  // provide control over cross-origin image handling (#2238)\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\n  if (options.context === 'image' && options.crossOrigin) {\n    result.crossOrigin = options.crossOrigin + '';\n  }\n\n  // return\n  return result;\n}\n\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\nfunction fileLoader(fs) {\n  return fs\n    ? filename => new Promise((accept, reject) => {\n        fs.readFile(filename, (error, data) => {\n          if (error) reject(error);\n          else accept(data);\n        });\n      })\n    : fileReject;\n}\n\n/**\n * Default file system loader that simply rejects.\n */\nasync function fileReject() {\n  error('No file system access.');\n}\n\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\nfunction httpLoader(fetch) {\n  return fetch\n    ? async function(url, options) {\n        const opt = extend({}, this.options.http, options),\n              type = options && options.response,\n              response = await fetch(url, opt);\n\n        return !response.ok\n          ? error(response.status + '' + response.statusText)\n          : isFunction(response[type]) ? response[type]()\n          : response.text();\n      }\n    : httpReject;\n}\n\n/**\n * Default http request handler that simply rejects.\n */\nasync function httpReject() {\n  error('No HTTP fetch method available.');\n}\n"]},"metadata":{},"sourceType":"module"}