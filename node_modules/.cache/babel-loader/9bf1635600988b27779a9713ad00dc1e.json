{"ast":null,"code":"import { array } from 'vega-util';\nimport { isConditionalDef, isConditionalSelection } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\n\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n  const condition = isConditionalDef(channelDef) && channelDef.condition;\n  const valueRef = refFn(channelDef);\n\n  if (condition) {\n    const conditions = array(condition);\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c) ? parseSelectionPredicate(model, c.selection) // FIXME: remove casting once TS is no longer dumb about it\n      : expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n\n      return Object.assign({\n        test\n      }, conditionValueRef);\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {\n      [vgChannel]: valueRef\n    } : {};\n  }\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/conditional.ts"],"names":[],"mappings":"AAAA,SAAQ,KAAR,QAAoB,WAApB;AACA,SAIE,gBAJF,EAKE,sBALF,QAMO,qBANP;AASA,SAAQ,UAAR,QAAyB,iBAAzB;AACA,SAAQ,uBAAR,QAAsC,uBAAtC;AAGA;;;AAGG;;AACH,OAAM,SAAU,aAAV,CACJ,KADI,EAEJ,UAFI,EAGJ,SAHI,EAIJ,KAJI,EAI2B;AAE/B,QAAM,SAAS,GAAG,gBAAgB,CAAK,UAAL,CAAhB,IAAoC,UAAU,CAAC,SAAjE;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,UAAD,CAAtB;;AACA,MAAI,SAAJ,EAAe;AACb,UAAM,UAAU,GAAG,KAAK,CAAC,SAAD,CAAxB;AACA,UAAM,YAAY,GAAG,UAAU,CAAC,GAAX,CAAe,CAAC,IAAG;AACtC,YAAM,iBAAiB,GAAG,KAAK,CAAC,CAAD,CAA/B;AACA,YAAM,IAAI,GAAG,sBAAsB,CAAM,CAAN,CAAtB,GACT,uBAAuB,CAAC,KAAD,EAAS,CAA+B,CAAC,SAAzC,CADd,CACkE;AADlE,QAET,UAAU,CAAC,KAAD,EAAS,CAA+B,CAAC,IAAzC,CAFd,CAFsC,CAIwB;;AAC9D,aAAA,MAAA,CAAA,MAAA,CAAA;AACE,QAAA;AADF,OAAA,EAEK,iBAFL,CAAA;AAID,KAToB,CAArB;AAUA,WAAO;AACL,OAAC,SAAD,GAAa,CAAC,GAAG,YAAJ,EAAkB,IAAI,QAAQ,KAAK,SAAb,GAAyB,CAAC,QAAD,CAAzB,GAAsC,EAA1C,CAAlB;AADR,KAAP;AAGD,GAfD,MAeO;AACL,WAAO,QAAQ,KAAK,SAAb,GAAyB;AAAC,OAAC,SAAD,GAAa;AAAd,KAAzB,GAAmD,EAA1D;AACD;AACF","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { isConditionalDef, isConditionalSelection } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n    const condition = isConditionalDef(channelDef) && channelDef.condition;\n    const valueRef = refFn(channelDef);\n    if (condition) {\n        const conditions = array(condition);\n        const vgConditions = conditions.map(c => {\n            const conditionValueRef = refFn(c);\n            const test = isConditionalSelection(c)\n                ? parseSelectionPredicate(model, c.selection) // FIXME: remove casting once TS is no longer dumb about it\n                : expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n            return Object.assign({ test }, conditionValueRef);\n        });\n        return {\n            [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n        };\n    }\n    else {\n        return valueRef !== undefined ? { [vgChannel]: valueRef } : {};\n    }\n}\n//# sourceMappingURL=conditional.js.map"]},"metadata":{},"sourceType":"module"}