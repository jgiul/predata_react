{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { getSizeChannel, POSITION_SCALE_CHANNELS } from '../channel';\nimport { isFieldOrDatumDef } from '../channeldef';\nimport * as log from '../log';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty } from '../util';\nexport class RangeStepNormalizer {\n  constructor() {\n    this.name = 'RangeStep';\n  }\n\n  hasMatchingType(spec) {\n    var _a;\n\n    if (isUnitSpec(spec) && spec.encoding) {\n      for (const channel of POSITION_SCALE_CHANNELS) {\n        const def = spec.encoding[channel];\n\n        if (def && isFieldOrDatumDef(def)) {\n          if ((_a = def === null || def === void 0 ? void 0 : def.scale) === null || _a === void 0 ? void 0 : _a['rangeStep']) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  run(spec) {\n    var _a;\n\n    const sizeMixins = {};\n    let encoding = Object.assign({}, spec.encoding);\n\n    for (const channel of POSITION_SCALE_CHANNELS) {\n      const sizeType = getSizeChannel(channel);\n      const def = encoding[channel];\n\n      if (def && isFieldOrDatumDef(def)) {\n        if ((_a = def === null || def === void 0 ? void 0 : def.scale) === null || _a === void 0 ? void 0 : _a['rangeStep']) {\n          const {\n            scale\n          } = def,\n                defWithoutScale = __rest(def, [\"scale\"]);\n\n          const _b = scale,\n                {\n            rangeStep\n          } = _b,\n                scaleWithoutRangeStep = __rest(_b, [\"rangeStep\"]);\n\n          sizeMixins[sizeType] = {\n            step: scale['rangeStep']\n          };\n          log.warn(log.message.RANGE_STEP_DEPRECATED);\n          encoding = Object.assign(Object.assign({}, encoding), {\n            [channel]: Object.assign(Object.assign({}, defWithoutScale), isEmpty(scaleWithoutRangeStep) ? {} : {\n              scale: scaleWithoutRangeStep\n            })\n          });\n        }\n      }\n    }\n\n    return Object.assign(Object.assign(Object.assign({}, sizeMixins), spec), {\n      encoding\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/normalize/rangestep.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAQ,cAAR,EAAwB,uBAAxB,QAAsD,YAAtD;AACA,SAAQ,iBAAR,QAAgC,eAAhC;AAEA,OAAO,KAAK,GAAZ,MAAqB,QAArB;AAGA,SAAyB,UAAzB,QAA8D,cAA9D;AACA,SAAQ,OAAR,QAAsB,SAAtB;AAKA,OAAM,MAAO,mBAAP,CAA0B;AAAhC,EAAA,WAAA,GAAA;AACS,SAAA,IAAA,GAAO,WAAP;AAgDR;;AA9CQ,EAAA,eAAe,CAAC,IAAD,EAAsC;;;AAC1D,QAAI,UAAU,CAAC,IAAD,CAAV,IAAoB,IAAI,CAAC,QAA7B,EAAuC;AACrC,WAAK,MAAM,OAAX,IAAsB,uBAAtB,EAA+C;AAC7C,cAAM,GAAG,GAAG,IAAI,CAAC,QAAL,CAAc,OAAd,CAAZ;;AACA,YAAI,GAAG,IAAI,iBAAiB,CAAC,GAAD,CAA5B,EAAmC;AACjC,cAAA,CAAA,EAAA,GAAI,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAG,KAAA,CAAH,GAAA,GAAG,CAAE,KAAT,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAG,WAAH,CAAd,EAA+B;AAC7B,mBAAO,IAAP;AACD;AACF;AACF;AACF;;AACD,WAAO,KAAP;AACD;;AAEM,EAAA,GAAG,CAAC,IAAD,EAA4B;;;AACpC,UAAM,UAAU,GAAG,EAAnB;AACA,QAAI,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,IAAI,CAAC,QAAZ,CAAZ;;AAEA,SAAK,MAAM,OAAX,IAAsB,uBAAtB,EAA+C;AAC7C,YAAM,QAAQ,GAAG,cAAc,CAAC,OAAD,CAA/B;AACA,YAAM,GAAG,GAAG,QAAQ,CAAC,OAAD,CAApB;;AACA,UAAI,GAAG,IAAI,iBAAiB,CAAC,GAAD,CAA5B,EAAmC;AACjC,YAAA,CAAA,EAAA,GAAI,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAG,KAAA,CAAH,GAAA,GAAG,CAAE,KAAT,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAG,WAAH,CAAd,EAA+B;AAC7B,gBAAM;AAAC,YAAA;AAAD,cAA8B,GAApC;AAAA,gBAAiB,eAAe,GAAA,MAAA,CAAI,GAAJ,EAA1B,CAAA,OAAA,CAA0B,CAAhC;;AAEA,gBAAM,EAAA,GAAwC,KAA9C;AAAA,gBAAM;AAAC,YAAA;AAAD,cAAU,EAAhB;AAAA,gBAAqB,qBAAqB,GAAA,MAAA,CAAA,EAAA,EAApC,CAAA,WAAA,CAAoC,CAA1C;;AACA,UAAA,UAAU,CAAC,QAAD,CAAV,GAAuB;AAAC,YAAA,IAAI,EAAE,KAAK,CAAC,WAAD;AAAZ,WAAvB;AAEA,UAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,OAAJ,CAAY,qBAArB;AAEA,UAAA,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACH,QADG,CAAA,EACK;AACX,aAAC,OAAD,GAAS,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACJ,eADI,CAAA,EAEH,OAAO,CAAC,qBAAD,CAAP,GAAiC,EAAjC,GAAsC;AAAC,cAAA,KAAK,EAAE;AAAR,aAFnC;AADE,WADL,CAAR;AAOD;AACF;AACF;;AACD,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,UADL,CAAA,EAEK,IAFL,CAAA,EAES;AACP,MAAA;AADO,KAFT,CAAA;AAKD;;AAhD6B","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { getSizeChannel, POSITION_SCALE_CHANNELS } from '../channel';\nimport { isFieldOrDatumDef } from '../channeldef';\nimport * as log from '../log';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty } from '../util';\nexport class RangeStepNormalizer {\n    constructor() {\n        this.name = 'RangeStep';\n    }\n    hasMatchingType(spec) {\n        var _a;\n        if (isUnitSpec(spec) && spec.encoding) {\n            for (const channel of POSITION_SCALE_CHANNELS) {\n                const def = spec.encoding[channel];\n                if (def && isFieldOrDatumDef(def)) {\n                    if ((_a = def === null || def === void 0 ? void 0 : def.scale) === null || _a === void 0 ? void 0 : _a['rangeStep']) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    run(spec) {\n        var _a;\n        const sizeMixins = {};\n        let encoding = Object.assign({}, spec.encoding);\n        for (const channel of POSITION_SCALE_CHANNELS) {\n            const sizeType = getSizeChannel(channel);\n            const def = encoding[channel];\n            if (def && isFieldOrDatumDef(def)) {\n                if ((_a = def === null || def === void 0 ? void 0 : def.scale) === null || _a === void 0 ? void 0 : _a['rangeStep']) {\n                    const { scale } = def, defWithoutScale = __rest(def, [\"scale\"]);\n                    const _b = scale, { rangeStep } = _b, scaleWithoutRangeStep = __rest(_b, [\"rangeStep\"]);\n                    sizeMixins[sizeType] = { step: scale['rangeStep'] };\n                    log.warn(log.message.RANGE_STEP_DEPRECATED);\n                    encoding = Object.assign(Object.assign({}, encoding), { [channel]: Object.assign(Object.assign({}, defWithoutScale), (isEmpty(scaleWithoutRangeStep) ? {} : { scale: scaleWithoutRangeStep })) });\n                }\n            }\n        }\n        return Object.assign(Object.assign(Object.assign({}, sizeMixins), spec), { encoding });\n    }\n}\n//# sourceMappingURL=rangestep.js.map"]},"metadata":{},"sourceType":"module"}