{"ast":null,"code":"import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, peek, identity, array, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, constants, codegen, functions, parse, CallExpression } from 'vega-expression';\nimport { geoBounds as geoBounds$1, geoCentroid as geoCentroid$1, geoArea as geoArea$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionResolve } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\n\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\n\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n        entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\n\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n\nfunction encode(item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n          target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n\n  return retval !== undefined ? retval : item;\n}\n\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return locale[method](spec)(value);\n};\n\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\n\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\n\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\n\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\n\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\n\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\n\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\n\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {// if data set does not exist, there's nothing to track\n    }\n  }\n}\n\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\n\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {// TODO: error handling? warning?\n    }\n  }\n}\n\nfunction getScale(name, ctx) {\n  let s;\n  return isFunction(name) ? name : isString(name) ? (s = ctx.scales[name]) && s.value : undefined;\n}\n\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions\n\n\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument\n\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n\n\n  return {\n    _bandwidth: args => \"this.__bandwidth(\".concat(ref(args[0]), \")\"),\n    _range: args => \"\".concat(ref(args[0]), \".range()\"),\n    _scale: args => \"\".concat(ref(args[0]), \"(\").concat(codegen(args[1]), \")\")\n  };\n}\n\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\n\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\n\nfunction inScope(item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n\n    item = item.mark.group;\n  }\n  return value;\n}\n\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n\n  return args[args.length - 1];\n}\n\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\n\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\n\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\n\nfunction luminance(color) {\n  const c = rgb(color),\n        r = channel_luminance_value(c.r),\n        g = channel_luminance_value(c.g),\n        b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\n\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n        lum2 = luminance(color2),\n        lumL = Math.max(lum1, lum2),\n        lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\n\nfunction merge() {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\n\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\n\nfunction modify(name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input,\n        stamp = df.stamp();\n  let changes = data.changes,\n      predicate,\n      key;\n\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n\n  if (insert) {\n    changes.insert(insert);\n  }\n\n  if (toggle) {\n    predicate = removePredicate(toggle);\n\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n\n  return 1;\n}\n\nfunction pinchDistance(event) {\n  const t = event.touches,\n        dx = t[0].clientX - t[1].clientX,\n        dy = t[0].clientY - t[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\n\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\n\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\n\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\n\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\n\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\n\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nfunction scaleGradient(scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n      min = stops[0],\n      max = peek(stops),\n      fraction = identity;\n\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\n\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\n\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\n\nconst datum = d => d.data;\n\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\n\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n        s = nodes[source],\n        t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\n\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n\nconst _window = () => typeof window !== 'undefined' && window || null;\n\nfunction screen() {\n  const w = _window();\n\n  return w ? w.screen : {};\n}\n\nfunction windowSize() {\n  const w = _window();\n\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\n\nfunction containerSize() {\n  const view = this.context.dataflow,\n        el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\n\nfunction intersect(b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n        box = new Bounds().set(u[0], u[1], v[0], v[1]),\n        scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\n\nfunction filter(opt) {\n  let p = null;\n\n  if (opt) {\n    const types = array(opt.marktype),\n          names = array(opt.markname);\n\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n\n  return p;\n}\n\nconst functionContext = {\n  random() {\n    return random();\n  },\n\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n\n  isDefined(_) {\n    return _ !== undefined;\n  },\n\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n\n  toBoolean,\n  toDate,\n  toNumber,\n  toString,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n  extent,\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n      // event functions\neventPrefix = 'event.vega.',\n      // event function prefix\nthisPrefix = 'this.',\n      // function context prefix\nastVisitors = {}; // AST visitors for dependency analysis\n// export code generator parameters\n\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => \"_[\".concat(stringValue(SignalPrefix + id), \"]\"),\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n}; // export code generator\n\nconst codeGenerator = codegen(codegenParams); // Build expression function registry\n\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n} // Register an expression function\n\n\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  } // register with the functionContext\n\n\n  functionContext[name] = fn; // if there is an astVisitor register that, too\n\n  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,\n  // we need to also register the function with it\n\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n} // register expression functions with ast visitors\n\n\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions\n\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\n\nfunction parser(expr, scope) {\n  const params = {}; // parse the expression to an abstract syntax tree (ast)\n\n  let ast;\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parse(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n          visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  const gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\n\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoShape, inScope, indata, indataVisitor, info, invert, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, range, scale, scaleGradient, scaleVisitor, screen, setdata, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };","map":{"version":3,"sources":["/Users/jg443z/1234/node_modules/vega-functions/build/vega-functions.module.js"],"names":["truthy","error","hasOwnProperty","isFunction","isString","stringValue","extend","isArray","isObject","peek","identity","array","isBoolean","isDate","isNumber","isRegExp","toBoolean","toDate","toNumber","toString","flush","lerp","pad","span","inrange","truncate","quarter","utcquarter","extent","clampRange","panLinear","panLog","panPow","panSymlog","zoomLinear","zoomLog","zoomPow","zoomSymlog","Literal","constants","codegen","functions","parse","CallExpression","geoBounds","geoBounds$1","geoCentroid","geoCentroid$1","geoArea","geoArea$1","rgb","lab","hcl","hsl","isTuple","bandSpace","scale","scale$1","scaleFraction","Gradient","pathRender","pathParse","Bounds","intersect","intersect$1","selectionVisitor","selectionTest","selectionResolve","random","cumulativeNormal","cumulativeLogNormal","cumulativeUniform","densityNormal","densityLogNormal","densityUniform","quantileNormal","quantileLogNormal","quantileUniform","sampleNormal","sampleLogNormal","sampleUniform","utcOffset","utcSequence","timeOffset","timeSequence","timeUnitSpecifier","week","utcweek","dayofyear","utcdayofyear","range","range$1","data","name","context","values","value","indata","field","index","entry","get","undefined","count","setdata","tuples","df","dataflow","input","pulse","changeset","remove","insert","encode","item","retval","target","mark","source","wrap","method","spec","locale","format","timeFormat","utcFormat","timeParse","utcParse","dateObj","Date","time","month","day","specifier","Number","isInteger","setYear","setMonth","setDate","call","monthFormat","monthAbbrevFormat","dayFormat","dayAbbrevFormat","DataPrefix","IndexPrefix","ScalePrefix","SignalPrefix","dataVisitor","args","scope","params","type","dataName","getData","tuplesRef","err","indataVisitor","indexName","indataRef","scaleVisitor","addScaleDependency","scales","scaleName","scaleRef","getScale","ctx","s","internalScaleFunctions","fnctx","visitors","__bandwidth","bandwidth","_bandwidth","_range","_scale","ref","arg","concat","geoMethod","methodName","globalMethod","projection","geojson","group","p","path","inScope","log","apply","slice","warn","length","arguments","info","debug","channel_luminance_value","channelValue","val","Math","pow","luminance","color","c","r","g","b","contrast","color1","color2","lum1","lum2","lumL","max","lumD","min","merge","unshift","equal","a","equalArray","equalObject","i","n","key","removePredicate","props","_","modify","toggle","stamp","changes","predicate","_trigger","runAfter","modified","run","some","pinchDistance","event","t","touches","dx","clientX","dy","clientY","sqrt","pinchAngle","atan2","bandspace","paddingInner","paddingOuter","copy","domain","invert","invertRange","invertExtent","scaleGradient","p0","p1","gradient","stops","fraction","interpolator","interpolate","ticks","push","forEach","stop","geoShape","pathShape","datum","d","treeNodes","tree","root","lookup","treePath","nodes","map","treeAncestors","node","ancestors","_window","window","screen","w","windowSize","innerWidth","innerHeight","containerSize","view","el","container","clientWidth","clientHeight","opt","u","v","box","set","scene","scenegraph","filter","types","marktype","names","markname","functionContext","isDefined","isValid","sequence","eventFunctions","eventPrefix","thisPrefix","astVisitors","codegenParams","forbidden","allowed","fieldvar","globalvar","id","buildFunctions","codeGenerator","fn","expressionFunction","visitor","parser","expr","ast","visit","callee","gen","globals","signalName","getSignal","signalRef","$expr","code","options","$fields","fields","$params","parseExpression"],"mappings":"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","sourcesContent":["import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, peek, identity, array, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, constants, codegen, functions, parse, CallExpression } from 'vega-expression';\nimport { geoBounds as geoBounds$1, geoCentroid as geoCentroid$1, geoArea as geoArea$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionResolve } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\n\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n        entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n\nfunction encode (item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n          target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n\n  return retval !== undefined ? retval : item;\n}\n\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return locale[method](spec)(value);\n};\n\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\n\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\n\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\n\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\n\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {// if data set does not exist, there's nothing to track\n    }\n  }\n}\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {// TODO: error handling? warning?\n    }\n  }\n}\n\nfunction getScale(name, ctx) {\n  let s;\n  return isFunction(name) ? name : isString(name) ? (s = ctx.scales[name]) && s.value : undefined;\n}\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions\n\n\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument\n\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n\n\n  return {\n    _bandwidth: args => \"this.__bandwidth(\".concat(ref(args[0]), \")\"),\n    _range: args => \"\".concat(ref(args[0]), \".range()\"),\n    _scale: args => \"\".concat(ref(args[0]), \"(\").concat(codegen(args[1]), \")\")\n  };\n}\n\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\n\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\n\nfunction inScope (item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n\n    item = item.mark.group;\n  }\n  return value;\n}\n\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n\n  return args[args.length - 1];\n}\n\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\n\nfunction luminance(color) {\n  const c = rgb(color),\n        r = channel_luminance_value(c.r),\n        g = channel_luminance_value(c.g),\n        b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n        lum2 = luminance(color2),\n        lumL = Math.max(lum1, lum2),\n        lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\n\nfunction merge () {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\n\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\n\nfunction modify (name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input,\n        stamp = df.stamp();\n  let changes = data.changes,\n      predicate,\n      key;\n\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n\n  if (insert) {\n    changes.insert(insert);\n  }\n\n  if (toggle) {\n    predicate = removePredicate(toggle);\n\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n\n  return 1;\n}\n\nfunction pinchDistance(event) {\n  const t = event.touches,\n        dx = t[0].clientX - t[1].clientX,\n        dy = t[0].clientY - t[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n}\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nfunction scaleGradient (scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n      min = stops[0],\n      max = peek(stops),\n      fraction = identity;\n\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\n\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\n\nconst datum = d => d.data;\n\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\n\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n        s = nodes[source],\n        t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n\nconst _window = () => typeof window !== 'undefined' && window || null;\n\nfunction screen() {\n  const w = _window();\n\n  return w ? w.screen : {};\n}\nfunction windowSize() {\n  const w = _window();\n\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\nfunction containerSize() {\n  const view = this.context.dataflow,\n        el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\n\nfunction intersect (b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n        box = new Bounds().set(u[0], u[1], v[0], v[1]),\n        scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\n\nfunction filter(opt) {\n  let p = null;\n\n  if (opt) {\n    const types = array(opt.marktype),\n          names = array(opt.markname);\n\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n\n  return p;\n}\n\nconst functionContext = {\n  random() {\n    return random();\n  },\n\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n\n  isDefined(_) {\n    return _ !== undefined;\n  },\n\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n\n  toBoolean,\n  toDate,\n  toNumber,\n  toString,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n  extent,\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n      // event functions\neventPrefix = 'event.vega.',\n      // event function prefix\nthisPrefix = 'this.',\n      // function context prefix\nastVisitors = {}; // AST visitors for dependency analysis\n// export code generator parameters\n\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => \"_[\".concat(stringValue(SignalPrefix + id), \"]\"),\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n}; // export code generator\n\nconst codeGenerator = codegen(codegenParams); // Build expression function registry\n\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n} // Register an expression function\n\n\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  } // register with the functionContext\n\n\n  functionContext[name] = fn; // if there is an astVisitor register that, too\n\n  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,\n  // we need to also register the function with it\n\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n} // register expression functions with ast visitors\n\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions\n\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\n\nfunction parser (expr, scope) {\n  const params = {}; // parse the expression to an abstract syntax tree (ast)\n\n  let ast;\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parse(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n          visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  const gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\n\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoShape, inScope, indata, indataVisitor, info, invert, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, range, scale, scaleGradient, scaleVisitor, screen, setdata, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };\n"]},"metadata":{},"sourceType":"module"}